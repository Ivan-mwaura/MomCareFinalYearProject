# -*- coding: utf-8 -*-
"""ROVERSSSSSSS 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1szKpcU8HiOSAlmMCyFcizXbAbItuwu29

# Loading Data
"""

import pandas as pd
import json

# Path to your JSON file
json_file_path = '/content/Bootcamp data.json'

# Read the JSON file into a pandas DataFrame
df = pd.read_json(json_file_path)

# Display the DataFrame (optional)
print(df)

"""# Importing Libraries"""

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import missingno as msno
import datetime as dt
import pandas as pd
from sklearn import tree
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
# Modelling
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import RepeatedStratifiedKFold, cross_validate
from sklearn.multiclass import (
    OneVsOneClassifier,
    OneVsRestClassifier,
    OutputCodeClassifier,
)

import xgboost as xgb
from xgboost import XGBClassifier
from imblearn.under_sampling import RandomUnderSampler
from imblearn.over_sampling import RandomOverSampler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, recall_score, ConfusionMatrixDisplay, classification_report, roc_auc_score
from sklearn.model_selection import RandomizedSearchCV, train_test_split
from scipy.stats import randint
from sklearn.ensemble import RandomForestClassifier
import warnings as wr

wr.filterwarnings('ignore')
print('Libraries Imported')

"""# Pre-Processing Data"""

columns_to_drop = ['Region']

# Drop the specified columns
df = df.drop(columns=columns_to_drop)

categorical_columns = [' CurrAgeGroup','Distance to health', 'Freq. of watching TV', 'Freq. of listening to radio', 'Freq. use internet', 'wealth index', 'Education level', 'Place of Residence', 'Head sex', 'Religion', 'Current marital_status']
one_hot_encoded_data = pd.get_dummies(df, columns=categorical_columns, drop_first=True)

# Replace False with 0 and True with 1
one_hot_encoded_data.replace({False: 0, True: 1}, inplace=True)

# Clean the ANC column: replace non-numeric values with NaN, then drop or fill NaNs
one_hot_encoded_data['ANC'] = pd.to_numeric(one_hot_encoded_data['ANC'], errors='coerce')

median_value = one_hot_encoded_data['ANC'].median()
one_hot_encoded_data['ANC'] = one_hot_encoded_data['ANC'].fillna(median_value)

# Convert the ANC column to integers
one_hot_encoded_data['ANC'] = one_hot_encoded_data['ANC'].astype(int)

# Apply the transformation
one_hot_encoded_data['ANC_Binary'] = one_hot_encoded_data['ANC'].apply(lambda x: 1 if x >= 4 else 0)

# Display the modified DataFrame
one_hot_encoded_data.head()

# Specify the columns to drop
columns_to_drop = ['ANC']

# Drop the specified columns
data = one_hot_encoded_data.drop(columns=columns_to_drop)

from sklearn.feature_selection import VarianceThreshold

# Prepare features and target
X = data.drop('ANC_Binary', axis=1)  #ANC_Binary is the target column
y = data['ANC_Binary']

# Initialize VarianceThreshold
selector = VarianceThreshold(threshold=0.01)
X_reduced = selector.fit_transform(X)

# Get the selected features
selected_features = X.columns[selector.get_support()]

# Print the selected features
print("Selected features:")
print(selected_features)


# Split the data
X_train, X_test, y_train, y_test = train_test_split(X_reduced, y, test_size=0.2, random_state=42)

# Initialize and train the model
model3 = XGBClassifier(subsample=0.9, n_estimators=20, min_child_weight=8,
                       max_depth=17, learning_rate=0.1, colsample_bytree=0.6, random_state=42)
model3.fit(X_train, y_train)

# Make predictions
y_pred = model3.predict(X_test)

# Evaluate the model
accuracy2 = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy2}')

cm2 = confusion_matrix(y_test, y_pred)
print(f'Confusion Matrix:\n{cm2}')

cr2 = classification_report(y_test, y_pred)
print(f'Classification Report:\n{cr2}')